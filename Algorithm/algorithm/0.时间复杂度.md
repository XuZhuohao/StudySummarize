# 时间复杂度





## 1. 概述



`算法时间复杂度：` 用来度量算法执行时间的多少，用大O阶表示
$$
时间复杂度\space T(n)=O(f(n)) \\
n 为问题规模，即问题的大小
$$

> **T(n)=O(f(n))**
>
> **其中，T(n)就是算法的时间复杂度；**
>
> **f(n)表示执行与算法优劣和问题规模有关的执行数；**
>
> **O()表示一种运算符号，和+-\*/类似。作用就是去除其他项，包括与最高项相乘的常数，只保留最高项，比如f(n)=2n^2+1,O(f(n))=O(n^2)**





**时间**，此处的时间指执行算法消耗的时间，影响**时间**的因素为：

1. 计算机执行每条指令的速度->硬件层面
2. 编译产生的代码质量->软件层面
3. 算法的好坏(算法使用的策略)
4. 问题规模

不同机器，不同编译器影响第1,2点因素，可以忽略其影响来讨论时间的问题。

既然执行时间受**算法好坏**和**问题规模n**的影响，那么执行时间就是它俩的函数。

而**算法好坏**和**问题规模n**都是会影响执行次数，以此影响执行时间，故：`算法执行时间可以用执行次数表示`





## 2. Master Method（主项定理）

在分析根据递归方程分析算法的时间复杂度时，常见到如下形式的方程:
$$
T(n) = a*T({n \over b}) + f(n^d) \\
a>1, b>1, d>1,f(n^d)一般是个简单函数
$$

$$
观察该公式，用递归树解可得，\\
右边第一项为:\space  a*T({n \over b})=n^{log_ba} \\
右边第二项为:\space  f(n^d) \space\\
所以主项定理本质就是对比这两个函数，对比n的指数 \\
即有 T(n)=\left\{
\begin{aligned}
&O(n^{log_ba})& &if\space d<log_ba \space (a>b^d)& \\
&O(n^d *lgn )& &if\space d=log_ba \space (a=b^d)& \\
&O(n^d)& &if\space d>log_ba \space (a<b^d)& \\
\end{aligned}
\right.
$$






























