# 算法（Algorithm）

算法是**解决特定问题求解步骤的描述**，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。



## 1.算法

### 1.1 高斯求和

求 1+2+...99+100=?

```java
int sum = 0, n = 100;
for(int i = 1; i <= n; i++){
    sum += i;
}
System.out.println(sum);
```

高斯求和

```java
int sum = 0, n = 100;
sum = (1 + n) * n / 2;
System.out.println(sum);
```



### 1.2 算法的特性

#### 1.2.1 输入输出

- 有0个或多个输入
- 有1个或多个输出



#### 1.2.2 有穷性

**有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。**

*死循环不满足有穷性*



#### 1.2.2 确定性

**确定性：算法的每一步骤都具有确定的含义，不会出现二义性。**



#### 1.2.2 可行性

**可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。**



### 1.3 算法设计的要求

#### 1.3.1 正确性
**正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。**

- 算法程序没有语法错误。
- 算法程序对于合法的输入数据能够产生满足要求的输出结果。
- 算法程序对于非法的输入数据能够得出满足规格说明的结果。
- 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。

*第四层几乎不可达，无法去测试到所有数据，所以一般把是否满足到层次三作为一个算法是否正确的评判标准*



#### 1.3.2 可读性
**可读性：算法设计的另一目的是为了便于阅读、理解和交流。**



####  1.3.3健壮性
**健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。**



#### 1.3.4时间效率高和存储量低

**设计算法应该尽量满足时间效率高和存储量低的需求。**





##　2. 算法的时间复杂度

在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模n的某个函数。

**分析算法的复杂度，关键就是要分析循环结构的运行情况。**



### 2.1 推导大 O 阶的方法

**步骤：**

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。



### 2.2 常数阶

对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着 n 的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是 O(1)。

```java
int sum = 0, n = 100;
sum = (1 + n) * n / 2;  //执行1次
sum = (1 + n) * n / 2;  //执行1次
sum = (1 + n) * n / 2;  //执行1次
... // (无论多少个)
sum = (1 + n) * n / 2;  //执行1次
System.out.println(sum);
```

-> O(1)

### 2.3 线性阶

```java
int n = 100;
for(int i = 0; i < n; i++ ){
    // 执行时间复杂度 O(1)
}
```

-> O(n)



### 2.4 对数阶

```java
int count = 1;
while(count < n){
    count = count * 2;
    /* 时间复杂度为 O(1) 的程序步骤序列 */
}
```

求**时间复杂度**： 
$$
主要就是多少个 2 相乘后会大于 n，即 \\
从： 2^x = n \\
得： x = log_2n \\
所以时间复杂度为 O_{(n)} = log_2n
$$


### 2.5 平方阶

#### 2.5.1 常规

```java
for(int i = 0; i < m; i ++){
    for(int j = 0; j < n; j++){
        /* 时间复杂度为 O(1) 的程序步骤序列 */
    }
}
```

**时间复杂度：**
$$
O_{(n)} = O_{(n * m)} = O_{(n^2)}
$$


***由此总结***：**循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。**



#### 2.5.2 变形（1）

```java
for(int i = 0; i < m; i ++){
    for(int j = i; j < n; j++){ // 此处为 j = i 而非 j = 0
        /* 时间复杂度为 O(1) 的程序步骤序列 */
    }
}
```

**时间复杂度： **
$$
总执行次数为(高斯求和)： n + (n - 1) + (n -2) +...+ 1 = {(n + 1)*n\over 2} = {n^2 \over 2} + {n \over 2} \\
根据大O阶的推导方法2，只保留 {n^2 \over 2}  \\
根据大O阶的推导方法3，去除 {1 \over 2} 
所以最终得到时间复杂度为 O_{(n^2)}
$$


**其实理解大O推导不算难，难的是对数列的一些相关运算，这更多的是考察你的数学知识和能力**



### 2.6 常见的时间复杂度

| 阶          | 非正式术语 | 执行次数（举例）    |
| ----------- | ---------- | ------------------- |
| O(1)        | 常数阶     | 12                  |
| O(n)        | 线性阶     | 2n + 3              |
| O(n^2)      | 平方阶     | 3n^2 + 2n + 1       |
| O(logn)     | 对数阶     | 5log n + 20         |
| O(n long n) | nlog n 阶  | 2n + 3nlog n + 19   |
| O(n^3)      | 立方阶     | 6n^3 + 2n^2 + 3n +4 |
| O(2^n)      | 指数阶     | 2^n                 |

时间复杂度所耗费的时间从小到大依次是：
$$
O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$


### 2.7 最坏时间复杂度与平均时间复杂度

- **最坏时间复杂度：最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行**
- **平均时间复杂度：平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。**

***一般在没有特殊说明的情况下，都是指最坏时间复杂度。***



## 3. 算法的空间复杂度

**算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。**

通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，**通常都是指时间复杂度**。