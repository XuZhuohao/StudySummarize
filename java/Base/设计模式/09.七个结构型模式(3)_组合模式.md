# 组合模式-Composite Pattern

**组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】**

**(对象结构型模式)**

树形结构的处理



## 1. 引入

对于树形结构，如何更好地处理和抽象



## 2. 角色

- **Componet（抽象构件）：** 抽象层，为叶子构件和容器构件声明接口。可以包含所有子类共有行为的声明和实现。**定义了访问及管理子构件的方法**，如果增加子构件、删除子构件、获取子构件等。
-  **Leaf（叶子构件）：** 组合结构中表示叶子节点对象，没有子节点，实现业务行为，对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。
- **Composite（容器构件）：** 组合结构中表示容器节点对象，容器节点包含子节点（可以是叶节点，也可以是容器节点）。调用业务方法时，迭代调用其子节点业务方法。



## 3. 定义

组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。

组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，

组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。



### 3.1  透明组合模式

- Component中声明了所有用于管理成员对象的方法，包括add()、remove()以及getChild()等方法

- 所有构件类都有相同的接口，**叶子和容器提供的方法是一致的**，更容易使用

- 透明组合模式也是组合模式的标准形式

- 缺点

  - **不够安全**，因为叶子和容器有本质上的区别

  - 叶子对象管理成员对象的方法时没有意义的，容易出现运行时异常

    

### 3.2 安全组合模式

- 抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法
- **这种做法是安全的**，因为根本不向叶子对象提供这些管理成员对象的方法
- 缺点
  - **不够透明**，因为叶子构件和容器构件具有不同的方法
  - 客户端不能完全针对抽象编程，必须区别对待叶子和容器
- 在实际应用中，安全组合模式的使用频率也非常高



## 4. uml

### 4.1 透明模式

![Composite-Pattern-lucency](https://raw.githubusercontent.com/XuZhuohao/picture/master/java/Base/design-pattern/8.Composite-Pattern-lucency.png)



### 4.2 安全模式

![Composite-Pattern-safe](https://raw.githubusercontent.com/XuZhuohao/picture/master/java/Base/design-pattern/8.Composite-Pattern-safe.png)



## 5. 总结

### 5.1 模式名称(pattern name)

组合模式-Composite Pattern



### 5.2 问题(Problem)

树形结构的数据或系统，设计麻烦，编码复杂



### 5.3 解决方案(Solution)

通过抽象，构建一个抽象构件，泛化叶子和容器，使操作根据方便



### 5.4 效果(Consequences)

- 主要优点
  - 清晰定义分层次的复杂对象，让客户端忽略层次差异，**方便对整个层次结构进行控制；**
  - 客户端可以使用一个组合结构或单个对象，**不必区分使用**，简化了客户端的代码；
  - 新增和修改容器构件或叶子构件都不会影响现有的结构，**符合“开闭原则”**；
  - 为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。
- 主要缺点
  - 无法对容器中的构件类型进行限制。

### 5.5 使用场景

- 在具有整体和部分的层次结构中，希望忽略整体与部分的差异，客户端可以一致对待它们；
- 面向对象语言开发的系统中，需要处理一个树形结构；
- 系统中能够分离出叶子对象和容器对象，且类型不固定，需要增加新的类型。