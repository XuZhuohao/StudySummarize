# 算法4



## 1. 基础

## 2.排序

- **排序成本模型**：在研究排序算法时，我们需要计算比较和交换的数量。对于不交换元素的算法，我们会计算访问数组的次数。

- 排序算法的**额外内存开销**和运行时间是同等重要的

  

### 2.1 初级排序

#### 2.1.1 选择排序 (Selection Sort)

##### **选择排序**

1. 找到数组中最小的那个元素，
2. 将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）
3. 在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。
4. 如此往复，直到将整个数组排序

> 因为它在不断地选择剩余元素之中的最小者，所以命名为选择排序



##### **code**

```java
public static <T extends Comparable<? super T>> void sort(T[] data) {
    for (int i = 0; i < data.length; i++) {
        // -1 < 0 = 1 >
        for (int j = i + 1; j < data.length; j++) {
            if (data[i].compareTo(data[j]) > 0) {
                DataUtil.swap(data, i, j);
            }
        }
    }
}
```



##### **复杂度计算**

- 时间复杂度

$$
(n-1) + (n-2)+...(n-n)  \\
\approx n + (n-1) + (n-2)+...(n-n) \\
=  {(n + 1)*n\over 2} = {n^2 \over 2} + {n \over 2} \\
根据大 O 阶的推导方法（\\
1. 用常数1取代运行时间中的所有加法常数。\\
2. 在修改后的运行次数函数中，只保留最高阶项。\\
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数）\\
得：时间复杂度 = O(n^2)
$$

- 空间复杂度

大约N2/2次比较和N次交换





#### 2.1.2 插入排序（Insertion Sort）



##### 插入排序

1. 循环把数据往前插入到合适的位置











