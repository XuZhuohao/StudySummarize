# 原型模式-Prototype Pattern

原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

通过一个原型对象克隆出多个一模一样的对象

抽象工厂模式-Abstract Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】

由于工厂方法模式中具体工厂类和具体产品类是一一对应的关系，导致系统开销增大，代码中存在大量的工厂类，通过将**相关的产品组成"产品族"，再由同一个工厂来统一生产**。

## 1. 引入





## 2. 角色

●Prototype（抽象原型类）：声明克隆方法的接口，是所有具体原型类的公共父类，也可以是具体实现类。

● ConcretePrototype（具体原型类）：实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。

● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。



## 3. 定义

使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对



## 4. uml

### ![Abstract Factory Pattern](https://raw.githubusercontent.com/XuZhuohao/picture/master/java/Base/design-pattern/3.Abstract Factory Pattern.png)



## 5. 总结

### 5.1 模式名称(pattern name)

抽象工厂模式



### 5.2 问题(Problem)

解决工程方法模式中，工程类过多的问题



### 5.3 解决方案(Solution)

提供一个创建一系列相关或相互依赖对象的接口



### 5.4 效果(Consequences)

- 主要优点
  - 增加产品族，很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改

- 主要缺点
  - 增加新的产品等级结构很麻烦，需要修改所有的工厂角色，违背了“开闭原则”。抽象工厂模式的这种性质称为**“开闭原则”的倾斜**

### 5.5 使用场景

- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦
- 系统中有多个产品族，且每次使用某一产品族，方便动态修改和新增产品族。
- 约束统一产品族，没有任何关系的对象，具有统一的共同约束
- 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。