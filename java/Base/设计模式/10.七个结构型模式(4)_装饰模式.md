# 装饰模式-Decorator Pattern

**装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】**

**(对象结构型模式)**

扩展系统功能，不改变原有功能的基础上，更加符合使用需求



## 1. 引入

毛胚房装修，并没有改变房子原来的功能，使房子更符合用户的需求



## 2. 角色

- **Component（抽象构件）：** 具体构件和抽象装饰类的共同父类 ，声明了在具体构件中实现的业务方法，使客户端可以用一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。
- **ConcreteComponent（具体构件）：** 抽象构件类的子类，定义具体的构建对象，实现抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。
- **Decorator（抽象装饰类）：** 抽象构件类的子类，用于给具体构件增加职责，具体职责在其子类中实现；维护一个指向抽象构件对象的应用，通过改应用，可以调用装饰前的方法，并通过其子类扩展该方法，以达到装饰的目的。
- **ConcreteDecorator（具体装饰类）：** 它是抽象装饰类的子类，负责向构件添加新的职责。



## 3. 定义

动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。



### 3.1 透明装饰模式

- 客户端完全针对抽象编程，不应该将对象声明为具体的构件类型或具体装饰类型，而应该全部为抽象构件类型；
- 对已装饰过的对象进行多次装饰，得到更复杂的对象。

### 3.2 半透明装饰模式

- 设计更加灵活；
- 最大的缺点在于不能实现对同一个对象的多次装饰；
- 需要调用新增的业务方法，需要用具体装饰类型来定义装饰之后的对象；
- 客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。

### 3.3 注意

- 尽量使用透明装饰模式；
- 不要把太多的行为放到具体构件类中，而是通过装饰类对其进行扩展；
- 如果只有一个具体构建类，那么抽象装饰类可以作为该构件类的直接子类。

## 4. uml

![Decorator-Pattern](https://raw.githubusercontent.com/XuZhuohao/picture/master/java/Base/design-pattern/9.Decorator-Pattern.png)



## 5. 总结

### 5.1 模式名称(pattern name)

装饰模式-Decorator Pattern



### 5.2 问题(Problem)

对于原代码中的对象需要添加职责时，如果通过继承方式去扩展，会导致大量重复的代码（多种类型要添加同一个职责），客户端也无法进行抽象编程



### 5.3 解决方案(Solution)

通过装饰类为对象增加一些额外的职责



### 5.4 效果(Consequences)

- 主要优点
  - 装饰模式比继承更加灵活，降低类的个数增加的速度；
  
  - 通过动态的方式来扩展一个对象的功能，配置不同的装饰类实现不同的行为；
  
  - 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及使用顺序，创造不同行为的组合；
  
  - 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。
  
- 主要缺点
  
  - 产生很多小对象，这些对象的区别在于连接方式的不同，而不是类或者属性值不同，大量小对象占用跟多的系统资源，影响程序的性能；
  - 装饰模式比继承更加灵活，也意味着更容易出错，排错也困难，多重装饰时需要逐级排查。

### 5.5 使用场景

- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 不能使用继承的方式进行扩展时：
  - 系统存在大量独立的扩展，扩展和扩展间组合将产生大量的子类；
  - 类已被定义为不能被继承；

