# 工厂方法模式-Factory Method Pattern
工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】



简单工厂模式使用时，引入新的产品需要修改工厂类代码，违背“开闭原则"，如何实**现增加新产品而不影响已有代码**，工厂方法模式为此而生



## 1. 引入

针对工厂模式使用有以下问题：

- 工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大；

- 系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”；
- 工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高。



## 2.角色

● Product（抽象产品）：定义产品的接口，是产品对象的公共父类。

● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，**具体工厂和具体产品之间一一对应**。

● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。**抽象工厂是工厂方法模式的核心**，所有创建对象的工厂类都必须实现该接口。

● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可**由客户端调用**，**生成一个具体产品类的实例**。



## 3. 定义

定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。  

- **与简单工厂模式最重要的区别是引入了抽象工厂角色**
- 抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责
- 由客户端使用具体工厂类，创建对应的对象



## 4. uml

### 4.1 工厂方法模式

![factory method pattern](https://raw.githubusercontent.com/XuZhuohao/picture/master/java/Base/design-pattern/2.Factory-Method-Pattern.png)



### 4.2 重载工厂方法

根据不同的入参生产产品(同一个具体的工厂类生产出来的产品必须是同一个类型的)

### 4.3 隐藏工厂方法

![factory method pattern hidden](https://raw.githubusercontent.com/XuZhuohao/picture/master/java/Base/design-pattern/2.Factory-Method-Pattern-hidden.png)



## 5 总结

### 5.1 模式名称(pattern name)

工厂方法模式-Factory Method Pattern



### 5.2 问题(Problem)

针对简单工厂类的逻辑过于复杂，不方便维护，不够灵活



### 5.3 解决方案(Solution)

定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。



### 5.4 效果(Consequences)

- 主要优点
  - 对客户端**隐藏产品类型和实例化细节**
  - 工厂可以自主确定创建何种产品对象
  - 新增产品类时，无需修改原工厂类，符合了开闭原则


- 主要缺点
  - 具体工厂类要和具体产品类一一对应，**增加代码量和系统复杂度**，**增加编译和运行开销**
  - 使用抽象层进行定义，增加了系统的抽象性和理解难度



### 5.5 使用场景

在以下情况下可以考虑使用工厂方法模式：

- 对客户端隐藏具体产品类
- 抽象工厂类只提供接口，并且返回抽象产品类，利用多态性和里氏替换原则，从而增加系统扩展性





