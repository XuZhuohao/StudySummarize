# 基本算法



## 1.排序算法

### 1.1 选择排序（Selection Sort）

**步骤**

1. 找到最小的元素
2. 与未交换元素的第1位交换位置
3. 从第一点开始重复

```code
重复（元素个数-1）次{
  把第一个没有排序过的元素设置为最小值
  遍历每个没有排序过的元素{
    如果元素 < 现在的最小值 {
      将此元素设置成为新的最小值
    }
  }
  将最小值和第一个没有排序过的位置交换
}
```



### 1.2 插入排序（Insertion Sort）

**步骤**

1. 设置第一个元素为已排序
2. 循环获取下一个元素a
3. 从已排序数据尾部到头部遍历比较
4. 如果 a 大于循环元素则位置保持不变，跳出 3 循环
5. 如果 a 小于循环元素则，交互元素位置，继续 3 循环
6. 继续 2 循环

```code
将第一个元素标记为已排序
遍历每个没有排序过的元素
  “提取” 元素 X
  i = 最后排序过元素的指数 到 0 的遍历
    如果现在排序过的元素 > 提取的元素
      将排序过的元素向右移一格
    否则：插入提取的元素
```



### 1.3 归并排序（Merge Sort）

**步骤**

- 递归思路
  1. 以游标来划分区间，leftIndex 为区间起始， rightIndex 为区间闭合，midIndex 为区间中间
  2. 如果 leftIndex >= rightIndex ,不需要处理，直接返回
  3. 获取 midIndex = (leftIndex  + rightIndex )/2
  4. 递归处理左区间 (leftIndex: leftIndex, rightIndex: midIndex)
  5. 递归处理右区间 (leftIndex: midIndex + 1, rightIndex: rightIndex )
  6. 合并左右区间： 用 leftIndex 和 midIndex+1 分别作为起始，进行对比

```code
将每个元素拆分成大小为1的部分

recursively merge adjacent partitions

  i = 左侧开始项指数 到 右侧最后项指数 的遍历（两端包括）

    如果左侧首值 <= 右侧首值

      拷贝左侧首项的值

    否则： 拷贝右侧部分首值

将元素拷贝进原来的数组中
```























