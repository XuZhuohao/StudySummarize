# base



## 1. 集合







|              | ArrayList                                                    | Vector                                                       | LinkedList                                 | HashMap1.7                                                   | HashMap1.8                                                   | HashSet  | LinkedHashMap    |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | ---------------- |
| **结构**     | 数组                                                         | 数组                                                         | 双向链表                                   | 数组+链表                                                    | 数组+链表<br>数组+红黑树                                     | HashMap  | HashMap+双向链表 |
| **类型**     | --                                                           | 同步容器                                                     | --                                         |                                                              |                                                              |          |                  |
| **锁**       | --                                                           | synchronized add()                                           | --                                         |                                                              |                                                              |          |                  |
| **扩容点**   | 空间不足                                                     | 空间不足                                                     | --                                         | 1.size > 容量 * 负载因子<br>2.默认:容量16，负载因子0.75<br>3.容量为2的n次幂 | 1.size > 容量 * 负载因子<br/>2.默认:容量16，负载因子0.75<br/>3.容量为2的n次幂 |          |                  |
| **扩容规则** | 1.增加原数组的 1/2<br>2.扩展1/2仍旧不足，去需要空间大小<br>3.扩展大小大于Integer.MAX_VALUE - 8取大小为 Integer.MAX_VALUE | 1.增加，创建是设置的增容量大小，如未设置，增加为目前的两杯<br>2.扩展第一点仍旧不足，取需要空间大小<br/>3.扩展大小大于Integer.MAX_VALUE - 8取大小为 Integer.MAX_VALUE | --                                         | 1.原大小大于2^31，取Integer.MAX_VALUE<br>2.否则，取原容量*2，再校验是否通过第一点 | 1.原大小大于2^31，取Integer.MAX_VALUE<br/>2.否则，取原容量*2，再校验是否通过第一点 |          |                  |
| **扩容方式** | 数据复制                                                     | 数据复制                                                     | --                                         | 数据复制,重新计算hash和index                                 | 数据复制,重新计算index                                       | 数据复制 |                  |
| **get**      | --                                                           | --                                                           | 1.从就近头去遍历获取<br>2.时间复杂度O(n/2) | --                                                           |                                                              |          |                  |







### 1.1 HashMap



#### 1.1.1 哈希表

##### 1.1.1.1 什么是 hash

> **哈希表**又叫**散列表**，是一种根据设定的映射函数f(key)将一组关键字映射到一个有限且连续的地址区间上，并以关键字在地址区间中的“像”作为元素在表中的存储位置的一种数据结构。这个映射过程称为**哈希造表**或者**散列**，这个映射函数f(key)即为**哈希函数**也叫**散列函数**，通过哈希函数得到的存储位置称为**哈希地址**或**散列地址**

- 在无序线性表中查找一个元素时间复杂度 T(n) = O(n)
- 哈希表通过函数 f(n) 来计算出对应元素的地址，以此来快速查找元素，即：T(n) = O(f(n)) = O(1) 



##### 1.1.1.2 散列函数

###### 除留取余法

> 取关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址。即：f(key)=key % p, p≤m;



###### **直接定址法**

> 直接定址法是指取关键字或关键字的某个线性函数值为哈希地址。即： f(key)=key 或者 f(key)=a*key+b



###### 数字分析法

> 假设关键字是以为基的数（如以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可以选取关键字的若干位数组成哈希表。





##### 1.1.1.3 散列函数  - BKDRHash





##### 1.1.1.4 哈希冲突

> 对于不同的关键字，可能得到同一个哈希地址，即key1≠key2,而 f(key1)=f(key2)，对于这种现象我们称之为**哈希冲突**，也叫**哈希碰撞**
>
> 选择不同的hash函数，造成的哈希碰撞也是不一样的，所以如何选择 hash 函数是非常重要得。





###### 解决哈希冲突

(1) **开放定址法**

**线性探测再散列**： 若当前key与原来key产生相同的哈希地址，则当前key存在该地址之后没有存任何元素的地址中

**二次探测再散列**： 若当前key与原来key产生相同的哈希地址，则当前key存在该地址后偏移量为（1,2,3...）的二次方地址处



(2) **再哈希法**

再哈希法即选取若干个不同的哈希函数，在产生哈希冲突的时候计算另一个哈希函数，直到不再发生冲突为止。



(3) **建立公共溢出区**

专门维护一个溢出表，当发生哈希冲突时，将值填入溢出表



(4) **链地址法**



##### 1.1.1.5 解决哈希冲突-链地址法

> 链地址法是指在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储。也就是凡是哈希地址为**i**的元素都插入到同一个链表中，元素插入的位置可以是表头（**头插法**），也可以是表尾（**尾插法**）









#### 1.1.2 尾插法和头插法

**jdk 1.7 ： 头插法**

**jdk 1.8 ： 尾插法**

头插法，会让最新的元素作为链表的头，保留在第一位，在插入新的重复数据时，并发发生扩容（扩容时重新分配空间），会导致hash重复的数据在链表中的顺序又一次颠倒，加并发插入的数据，形成环表。

尾插法，则让链表的顺序一直保持一致，不会发送变化。



#### 1.1.3 红黑树