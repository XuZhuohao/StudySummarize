# 适配器模式-Adapter Pattern

**适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】**

**(类结构型模式+对象结构型模式)**

协调各种不兼容的结构或方法



## 1. 引入

旧接口入参(或者使用)不适用于当前，对旧接口需要进行多一层包装使用。



## 2. 角色

- **Target（目标抽象类）：** 目标抽象类定义客户端需要的接口(业务抽象接口)；
- **Adapter（适配器类）：** 作为一个转换器，**对 Adaptee 和 Target 进行适配** ，通过继承(实现) Target 并关联 Adaptee 使二者产生关联；
- **Adaptee（适配者类）：** 被适配的角色，一般已经包含客户端希望使用的业务方法



## 3. 定义

**将一个接口转换成客户希望的另一个接口**，使接口不兼容的那些类可以一起工作，其别名为**包装器(Wrapper)**。

对象适配器和类适配器最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中是关联关系，而类适配器模式中是继承关系

### 3.1 双向适配器

对象适配器中，适配器类中同时实现两个接口，并关联两个接口进行相互调用。

```java
public class Adapter implements Target, Adaptee{
    private Target target;
    private Adaptee adaptee;
    public void targetMethod(){
        adaptee.adapteeMethod();
    }
    public void adapteeMethod(){
        target.targetMethod();
    }
} 
```

### 3.2 缺省适配器 - Default Adapter Pattern

实现一个接口但是不实现所有方法，可先设计一个抽象类实现该接口，并为每一个方法提供一个默认实现(空方法)，那么该抽象类的子类就可以选择性地覆盖某些方法，它适用于**不想使用一个接口中的所有方法**的情况，又称为**单接口适配器模式**。



## 4. uml

![Adapter-Pattern](https://raw.githubusercontent.com/XuZhuohao/picture/master/java/Base/design-pattern/7.Adapter-Pattern.png)

## 5. 总结

### 5.1 模式名称(pattern name)

适配器模式-Adapter Pattern



### 5.2 问题(Problem)

对旧有类不兼容，但是想要复用该类



### 5.3 解决方案(Solution)

创建一个适配器，对类进行兼容



### 5.4 效果(Consequences)

- 主要优点
  - 目标类和适配者解耦，通过适配器类来**复用适配者类**，无需修改原有结构；
  -  **增加了类的透明性和复用性** ，同一个适配者类可以在不同系统中被复用；
  - **灵活性和扩展性都非常好** ，通过更换适配器修改原有逻辑，完全符合“开闭原则”。
  - 类适配器
    - 适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强
  - 对象适配器
    - 可以把多个不同的适配者适配到同一个目标；
    - **可以适配一个适配者的子类**，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。
- 主要缺点
  - 类适配器
    - 不支持多重继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；
    - 适配者类不能为终类（final， sealed）；
    - 在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。
  - 对象适配器
    - 适配器中置换适配者类的某些方法比较麻烦，需要先编写适配者类的子类，再去适配子类

### 5.5 使用场景

- 系统要使用一些现有的类，但是类的方法不符合系统需要(入参类型，方法名)，甚至没有这些类的源代码；
- 想创建一个可以重复使用的类，去关联一些没太大关联的类。