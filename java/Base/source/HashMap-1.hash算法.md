# hash算法

## 1.概述

- 散列主要思想：结合节点关键码值来确定其存储地址
  - 关键码值 K 为自变量
  - 函数关系 h(K)，称为**散列函数**，是散列技术的核心
  - **保存时**，**通过 h(k) 计算得到的值，解释为节点存储地址，将结点存入到此存储单元中**
  - **检索**时，通过统一的方法计算地址，到相应的位置取到结点即可
  - 散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法

- 散列表（hash table）：
  - 概念：按散列存储方式构造的存储结构称为散列表（hash table）
  - **槽(slot)**：散列表中的一个位置
- 散列函数(hash function)：
  - 散列函数决定的存储位置称为**散列地址**
  - **散列函数决定关键码值(X.key)与散列地址h(X.key)之间的对应关系，通过这种关系来实现组织存储并进行检索**
- 一般构造
  - 散列表的存储空间为一个一维数组 HT[M]
  - 散列地址是数组的下标
  - 设计散列方法的目标：0 <= h(K) < M
  - **散列表的空间必须比结点的集合大**，空间换时间
  - 散列函数对于不相等的关键码计算出相同的散列地址，我们称这种现象为**冲突（collision）**
  - 发生冲突的两个关键码称为该散列函数的**同义词**



## 2. 散列算法

### 2.1 散列函数的选取原则

- 函数的值域必须在散列表的范围内
- 尽可能使得结点均匀分布，也就是尽量让不同的关键码具有不同的散列函数值
- 考虑各种因素：关键码长度、散列表大小、关键码分布情况、记录的检索频率等等



### 2.2 散列算法-除余法

关键码 x 除以 M （往往取散列表长度），并取余数为散列地址。

>  **h(x) = x mod M**



### 2.3 散列算法-乘余取整法

关键码key乘上一个常数A (0< A < 1)，提取乘积的小数部分，再用整数n乘以这个值，对结果向下取整，把它做为散列的地址

> ** hash ( key ) = _LOW( n × ( A × key % 1 ) )**



### 2.4 散列算法-平方取中法

**由于整数相除的运行速度通常比相乘要慢，所以有意识地避免使用除余法运算可以提高散列算法的运行时间**

先通过求关键码的平方值，从而扩大相近数的差别，然后根据表长度取中间的几位数（往往取二进制的比特位）作为散列函数值。因为一个乘积的中间几位数与乘数的每一数位都相关，所以由此产生的散列地址较为均匀。



| 关键字 | 关键字的平方 | 哈希函数值 |
| ------ | ------------ | ---------- |
| 1234   | 1522756      | 227        |
| 2143   | 4592449      | 924        |
| 4132   | 17073424     | 734        |
| 3214   | 10329796     | 297        |



## 3.  冲突解决的策略

冲突解决技术可以分为两类：

- **开散列方法( open hashing，也称为拉链法，separate chaining ):** 发生冲突的关键码存储在散列表主表之外
- **闭散列方法( closed hashing，也称为开地址方法，open addressing ):** 闭散列法把发生冲突的关键码存储在表中另一个槽内。

### 3.1 拉链法（分离链表法）

开散列方法的一种简单形式是把散列表中的每个槽定义为一个链表的表头。散列到一个特定槽的所有记录都放到这个槽的链表中。



### 3.2 闭散列方法(开放地址法)

闭散列方法把所有记录直接存储在散列表中。每个记录关键码key有一个由散列函数计算出来的基位置，即h(key)。如果要插入一个关键码，而另一个记录已经占据了R的基位置(发生碰撞)，那么就把R存储在表中的其它地址内，由冲突解决策略确定是哪个地址。













